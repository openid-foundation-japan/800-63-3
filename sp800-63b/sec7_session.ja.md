<a name="sec7"></a>

## 7. セッション管理
<!-- ## 7. Session Management -->

一度認証イベントが起きたあと、ユーザーが引き続きアプリケーションを継続して使用するときは、インタラクションの度に毎回認証イベントを繰り返す必要がないことが望まれる。 この要件は、ネットワーク経由で調整した幾つかのコンポーネントやアクターを含む認証イベントに関するフェデレーション シナリオ (ボリューム C で説明) で特に必要である。

<!-- Once an authentication event has taken place, it is often desirable to allow the user to continue using the application across multiple subsequent interactions without requiring the user to repeat the authentication event every time. This requirement is particularly true for federation scenarios (described in volume C), where the authentication event necessarily involves several components and actors coordinating across a network. -->

この動作を実現するため、*セッション* は、ある認証イベントへの応答によって開始されてもよい (MAY)。そしてそのセッションはそれが終了されるときまで維持されなければならない (SHALL)。 セッションは、活動がないときのタイムアウト、明示的なログアウトイベント、その他の理由など、様々な理由により終了されることがある。 セッションは、ユーザーが自分の存在を主張することによって、いくつかまたはすべての認証イベントを繰り返す再認証イベント (セクション 7.2 で説明) を通して維持されてもよい (MAY)。

<!-- To facilitate this behavior, a *session* MAY be started in response to an authentication event, and such a session SHALL continue until such time that it is terminated. The session MAY be terminated for any number of reasons, including but not limited to an inactivity timeout, an explicit logout event, or other means. The session MAY be continued through a reauthentication event (described in section 7.2), wherein the user repeats some or all of the initial authentication event, thereby asserting their presence again. -->

セッション管理は、ユーザビリティ要件としての連続的なクレデンシャルの提示において、キャッシュされたアンロック済みのクレデンシャルへのワークアラウンドを動機付けることや、まず認証イベントの新鮮さを否定することが望まれる。

<!-- Session management is preferable over continuous presentation of credentials as the usability requirements of such continuous presentation would incentivize workarounds such as cached unlocking credentials, negating the freshness of the authentication event in the first place.  -->

### 7.1. セッション バインディング
<!-- ### 7.1. Session Bindings -->

セッションは、サブスクライバーが動作しているブラウザー、アプリケーション、オペレーティング システム (セッション主体) と、サブスクライバーがアクセスする RP や CSP (セッション ホスト) のソフトウェアの間に発生する。 セッション シークレットは、サブスクライバーのソフトウェアとアクセスされているサービスの間で共有される。 このシークレットは、セッションの 2 つのエンドをバインドし、ユーザーがしばらくの間サービスを継続して使用することを許可する。 シークレットは、直接的にユーザのソフトウェアによって与えられてもよい (MAY)。(a bearer secret) また、暗号メカニズムを使用して保証されてもよい (MAY)。(a proof of possession secret：所持を証明されたシークレット)。

<!-- A session occurs between the software that a subscriber is running, such as a browser, application, or operating system (the session subject), and the RP or CSP that the subscriber is accessing (the session host). A session secret is shared between the subscriber's software and the service being accessed. This secret binds the two ends of the session, allowing the user to continue using the service over time. The secret MAY be presented directly by the user's software (a bearer secret) or MAY be proofed using a cryptographic mechanism (a proof of possession secret).  -->

セッションのバインドに使用されるシークレットは、認証イベントへの直接の応答としてセッション ホストによって生成されたものとする (SHALL)。 セッションは、その作成をトリガーした認証イベントの AAL プロパティを継承する必要がある (SHOULD)。セッションは認証イベントよりも低い AAL で考慮されてもよい (MAY)。また、認証のイベントよりも高い AAL とみなされることはない (SHALL NOT)。

<!-- The secret used for session binding SHALL be generated by the session host in direct response to an authentication event. A session SHOULD inherit the AAL properties of the authentication event which triggered its creation; a session MAY be considered at a lower AAL than the authentication event and SHALL NOT be considered at a higher AAL than the authentication event. -->

セッションのバインドに使用されるシークレット:

<!-- Secrets used for session binding:  -->

- インタラクションの間、通常はユーザ認証のすぐ後で、セッション ホストによって生成されなければならない (SHALL)。
- 承認された乱数生成器を使用して生成された、少なくとも 64 bit のエントロピーを含まねばならない (SHALL)。
- ユーザーのログアウト時に、セッション主体によって消去または無効にされなければならない (SHALL)。
- ユーザーがログアウトするとき、またはシークレットの期限が切れたとみなされるとき、ユーザー エンドポイントから消去されなければならない (SHOULD)。
- クロスサイトスクリプティング攻撃 (XSS) によるローカルストレージの暴露の可能性のため、HTML5 のローカル ストレージなど、安全でない場所に配置すべきでない (SHOULD NOT)。
- 認証済みの保護されたチャネルを使用してデバイスから送信、または受信されなければならない (SHALL)。
- セクション [4.1.4](#aal1reauth)、[4.2.4](#aal2reauth)、[4.3.4](#aal3reauth) (AAL) によって指定された時間のあとは、タイムアウトしなければならず、受け付けられてはならない (SHALL)。

<!--
- SHALL be generated by the session host during an interaction, typically immediately following user authentication
- SHALL be generated by an approved random bit generator and contain at least 64 bits of entropy
- SHALL be erased or invalidated by the session subject when the user logs out
- SHOULD be erased on the user endpoint when the user logs out or when the secret is deemed to have expired
- SHOULD not be placed in insecure locations such as HTML5 Local Storage due to the potential exposure of local storage to cross-site scripting (XSS) attacks
- SHALL be sent to and received from the device using an authenticated protected channel
- SHALL time out and not be accepted after the times specified in section [4.1.4](#aal1reauth), [4.2.4](#aal2reauth), and [4.3.4](#aal3reauth) (depending on AAL)
-->

セッションオーバータイムを管理するための複数の異なるメカニズムがある。 次のセクションは、追加要件と特定の各テクノロジーの考慮事項に沿って、3 つの例を示す。

<!-- There are several different mechanisms for managing a session over time. The following sections give three examples, along with additional requirements and considerations particular to each example technology. -->

#### 7.1.1. ブラウザー クッキー
<!-- #### 7.1.1. Browser Cookies -->

ブラウザー クッキーは、サービスにアクセスするユーザーのセッションの作成と追跡において、有力なメカニズムである。

<!-- Browser cookies are the predominant mechanism by which a session will be created and tracked for a user accessing a service.  -->

クッキー:

<!-- Cookies: -->

- セキュリティで保護された (HTTPS) セッションのみでアクセス可能なようにタグ付けされなければならない (SHALL)。
- ホスト名とパスの最小で実用的なセットにアクセス可能でなければならない (SHALL)。
- JavaScriptからアクセス不可 (HttpOnly) となるようにタグ付けされなければならない (SHOULD)。
- セッションの有効期間の後は、すぐに満了としてタグ付けされなければならない (SHOULD)。(この要件はクッキーの蓄積を制限することを目的としている。セッションタイムアウトの適用に依存すべきではない (SHALL NOT)。)

<!--
- SHALL be tagged to be accessible on secure (HTTPS) sessions only
- SHALL be accessible to the minimum practical set of hostnames and paths
- SHOULD be tagged to be inaccessible via JavaScript (HttpOnly)
- SHOULD be tagged to expire at or soon after the validity period of the session (This requirement is intended to limit the accumulation of cookies, but SHALL NOT be depended upon to enforce session timeouts.)
-->

#### 7.1.2. OAuth トークン
<!-- #### 7.1.2. OAuth Tokens -->

OAuth アクセス トークンは、認証イベントののち、ユーザに代わってアプリケーションが一連のサービスへアクセスすることを許可するために使用される。 OAuth アクセス トークンの存在は、他のシグナルがない場合、ユーザーの存在を示す RP によって解釈されてはならない (SHALL NOT)。 OAuth アクセス トークン (および関連付けられたリフレッシュ トークン) は、認証セッションが終了し、ユーザーがそのアプリケーションから去ったあとでも、有効であってもよい (MAY)。

<!-- An OAuth access token is be used to allow an application to access a set of services on behalf of a user following an authentication event. The presence of an OAuth access token SHALL NOT be interpreted by the RP to indicate the presence of the user, in the absence of other signals. The OAuth access token (and any associated refresh tokens) MAY be valid long after the authentication session has ended and the user has left the application in question. -->

#### 7.1.3. デバイス識別
<!-- #### 7.1.3. Device Identification -->

ユーザーとサービス間のセッションの制定には、相互 TLSやトークンのバインディングなど、安全なデバイスの識別についての様々な方法を使用する。

<!-- Other methods of secure device identification, including but not limited to mutual TLS, token binding, or other mechanisms, MAY be used to enact a session between a user and a service.  -->

### 7.2. 再認証
<!-- ### 7.2. Reauthentication -->

セッションは、ガイドラインのセクション[4.1.4](#aal1reauth), [4.2.4](#aal2reauth), and [4.3.4](#aal3reauth) (AALに依存する) に基づき、セッション シークレットの提示のみで過去へも延長されることはない (SHALL NOT)。

<!-- A session SHALL NOT be extended past the guidelines in sections [4.1.4](#aal1reauth), [4.2.4](#aal2reauth), and [4.3.4](#aal3reauth) (depending on AAL) based on presentation of the session secret alone.  -->

タイムアウトまたは他のアクションによってセッションが終了されるとき、ユーザーはプライマリの認証メカニズム、または AAL に従った適切なサブセットを使用して再認証をしてもよい (MAY)。

<!-- When a session is terminated due to a time-out or other action, the user MAY reauthenticate using their primary authentication mechanism or an appropriate subset thereof, depending on the AAL. -->

| AAL | Requirement      |
| --- | ---------------- |
| 1   | 任意の 1 つのファクターの提示 |
| 2   | 任意の 1 つのファクターの提示 |
| 3   | 全てのファクターの提示      |

<!--
|AAL|Requirement|
|----|----|
|1|Presentation of any one factor|
|2|Presentation of any one factor|
|3|Presentation of all factors|
-->

#### 7.2.1 フェデレーションまたはアサーションからの再認証
<!-- #### 7.2.1 Reauthentication from a federation or assertion -->

[フェデレーション プロトコル](sp800-63c#sec4) を使用してCSP と RP を接続するときは、セッション管理と再認証のために、特別な考慮が必要である。 CSP と RP のどちらもが、 おそらく個別のセッション管理を採用し、これらのセッション間にはどんな相関の仮定もない (SHALL NOT)。 その結果として、RP においてセッションが満了し、RPによって再認証が必要なとき、CSPにおいてセッションが満了しておらず、ユーザーを再認証することなく CSP でこのセッションから新しいアサーションを生成することができる可能性は十分にあり得る。 したがって、フェデレーション プロトコルを介して再認証を必要とする RP は (当該プロトコルでサポートされていれば) 最小の acceptable authentication age を CSP に示すこととする (SHALL)。CSPは (可能なら) この要求に答えるものとする (SHALL)。 すべてのケースで CSP は、アサーションが再認証のために十分であるかどうかを RP が決められるように、プライマリ認証イベントの時刻を RP へ伝達しなければならない (SHALL)。

<!-- When using a [federation protocol](sp800-63c#sec4) to connect the CSP and RP, special consideration needs to be made for session management and reauthentication. Both the CSP and RP are likely to employ separate session management technologies, and there SHALL NOT be any assumption of correlation between these sessions. Consequently, when a session expires at an RP and reauthentication is required by the RP, it is entirely possible that the session at the CSP is not expired and a new assertion could be generated from this session at the CSP without reauthenticating the user. Therefore, an RP requiring a reauthentication through a federation protocol SHALL indicate a minimum acceptable authentication age to the CSP (if possible within the protocol), and the CSP SHALL honor this request (if possible). The CSP in all cases SHALL communicate the primary authentication event time to the RP to allow the RP to decide if the assertion is sufficient for reauthentication or not. -->
